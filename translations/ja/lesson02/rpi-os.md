## 2.1: プロセッサの初期化

このレッスンでは、ARMプロセッサーをより詳しく見ていきます。ARMにはこのOSが
利用できるいくつかの重要な機能があります。そのような最初の機能は「例外レベル」と
呼ばれているものです。

### 例外レベル

ARM.v8アーキテクチャに対応したARMプロセッサには4つの例外レベルがあります。
例外レベル（略して`EL`）とは、すべての演算やレジスタのサブセットのみが
利用できるプロセッサの実行モードだと考えることができます。最も特権の少ない
例外レベルはレベル0です。このレベルでプロセッサが動作する場合、プロセッサは
ほとんど汎用レジスタ（X0～X30）とスタックポインタレジスタ（SP）しか使用しません。
EL0では、`STR`コマンドと`LDR`コマンドを使用して、メモリとの間でデータのロードと
ストアを行うことができます。また、ユーザープログラムでよく使われるいくつかの
命令も使用することができます。

オペレーティングシステムはプロセスの隔離を実現する必要があるので例外レベルを
扱う必要があります。ユーザプロセスが他のプロセスのデータにアクセスできては
いけません。このような動作を実現するためにOSはユーザプロセスを常にEL0で動作
させます。この例外レベルで動作する場合、プロセスは自身の仮想メモリしか使用
できず、仮想メモリの設定を変更する命令にはアクセスできません。このように
プロセスの隔離を確保するために、OSはプロセスごとに個別の仮想メモリのマッピングを
用意し、プロセッサをEL0にしてからユーザプロセスに実行を移す必要があります。

オペレーティングシステム自身は通常EL1で動作します。この例外レベルで動作する
場合、プロセッサは仮想メモリの設定を可能にするレジスタやいくつかのシステム
レジスタにアクセスすることができます。Raspberry PiのOSもEL1で動作します。

このOSでは例外レベル2と3はあまり使用しませんが、なぜ必要なのかを理解して
もらうために簡単に説明します。

EL2はハイパーバイザーを使用する時に使用します。この場合、ホストOSはEL2で動作し、
ゲストOSはEL1しか使用できません。これによりOSがユーザプロセスを隔離するのと
同様に、ホストOSがゲストOSを隔離することができます。

EL3はARMの「安全な世界」から「安全ではない世界」への移行に使用されます。
この抽象化は、2つの異なる「世界」で動作するソフトウェア間にすべてハードウェアに
よる隔離を提供するために存在します。「安全ではない世界」のアプリケーションからは
「安全な世界」に属する情報（命令とデータの両方）にアクセスしたり変更したり
することはできません。そして、この制約はハードウェアレベルで実施されます。

### カーネルをデバッグする

次にやりたいことは、現在使用している例外レベルを解明することです。しかし、
これを実行しようとしたとき、カーネルはある一定の文字列を画面に表示すること
しかできないことに気づきました。私に必要なものは [printf](https://en.wikipedia.org/wiki/Printf_format_string)
関数に相当するものです。`printf`があればさまざまなレジスタや変数の値を簡単に
表示することができます。このような機能はカーネルの開発には欠かせません。
なぜなら、デバッガは使えないので`printf`がプログラムの内部で何が起こっている
かを把握するための唯一の手段になるからです。

RPi OSのために車輪の再発明はせず、 [既存のpritfの実装](http://www.sparetimelabs.com/tinyprintf/tinyprintf.php)を
使うことにしました。この機能はほとんどが文字列の操作で構成されており、カーネル
開発者の観点からはあまり面白いものではありません。私が使った実装は非常に小さく、
外部依存性がないので、カーネルに簡単に組み込むことができます。私がしなければ
ならないことは、スクリーンに一文字を送信することができる`putc`関数を定義する
ことだけです。この関数は[`mini_uart.c#L59`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/src/mini_uart.c#L59)で定義されており、既存の`uart_send`
関数を利用しているだけです。また、`printf`ライブラリを初期化し、`putc`関数の
場所を指定する必要もあります。これは[一行のコード](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/src/kernel.c#L8)でできます。

### カレント例外レベルを知る

さて、`printf`関数が使えるようになったので、本来の目的である「OSがどの例外
レベルで起動されたのか」を解明できるようになりました。この質問に答えることが
できる小さな関数が[`utils.S#L1`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/src/utils.S#L1) で定義されています。次のようなものです。

```
.globl get_el
get_el:
    mrs x0, CurrentEL
    lsr x0, x0, #2
    ret
```

ここでは`mrs`命令を使用して`CurrentEL`システムレジスタの値を`x0`レジスタに
読み込んでいます。そして、この値を2ビット右にシフトします（`CurrentEL`
レジスタの最初の2ビットは予約されており、常に値が0であるため、これを行う
必要があります）。最終的に、レジスタ`x0`には現在の例外レベルを示す整数値が
残ります。あとはこの値を[このように](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/src/kernel.c#L10)表示するだけです。

```
    int el = get_el();
    printf("Exception level: %d \r\n", el);
```

これを再現したら、画面に`Exception level: 3`と表示されるはずです。

### カレント例外レベルを変更する

ARMアーキテクチャでは、すでに高いレベルで動作しているソフトウェアの
関与がなければ、プログラムが自身の例外レベルを上げることはできません。
これは完全に合理的です。そうでないと、すべてのプログラムは割り当てられた
ELから抜け出すことができ、他のプログラムのデータにアクセスできてしまう
からです。現在のELを変更できるのは、例外が発生した場合のみです。例外は
プログラムが何らかの不正な命令を実行した場合に起こります（たとえば、
存在しないアドレスのメモリ位置にアクセスしたり、0で割ろうとした場合です）。
また、アプリケーションは例外を発生させるのを目的として`svc`命令を実行
することができます。ハードウェアが生成する割込みも特殊なタイプの例外として
扱われます。例外が発生すると、次のような手順で処理されます（ここでは、
EL `n`で例外が処理されると仮定します。`n`は1、2、3のいずれかです）。

1. 現在の命令のアドレスが`ELR_ELn`レジスタに保存されます（このレジスタは
   `例外リンクレジスタ`と呼ばれています）。
2. 現在のプロセッサの状態が`SPSR_ELn`レジスタ（`プログラム状態保存レジスタ
   : Saved Program Status Register`）に保存されます。
3. 例外ハンドラが実行され、必要な処理を行います。
4. 例外ハンドラは`eret`命令を呼び出します。この命令は、プロセッサの状態を
   `SPSR_ELn`から復元し、`ELR_ELn`レジスタに格納されているアドレスから
   実行を再開します。

実際には、例外ハンドラはすべての汎用レジスタの状態も保存し、後で復元する
必要があるため、プロセスはもう少し複雑になります。このプロセスについては
次回のレッスンで詳しく説明します。現時点では、一般的なプロセスを理解し、
`ELR_ELn`と`SPSR_ELn`レジスタの意味を覚えておけばよいでしょう。

ここで重要なことは、例外ハンドラは例外が発生した場所に戻る義務はないと
いうことです。`ELR_ELn`と`SPSR_ELn`はどちらも書き込み可能であり、例外
ハンドラは必要に応じてそれらを変更することができます。このテクニックを
利用してEL3からEL1への切り替えを行いましょう。

### EL1へ切り替える

厳密に言えば私たちのOSはEL1に切り替える義務はありません。しかし、この
レベルにはOSに共通するすべてのタスクを実装するのに適した権限があるので
EL1は私たちにとって自然な選択です。また、例外レベルの切り替えが実際に
どのように行われるかを確認することは、興味深い実習となるでしょう。では、
[これを行うソースコード](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/src/boot.S#L17)を見てみましょう。

```
master:
    ldr    x0, =SCTLR_VALUE_MMU_DISABLED
    msr    sctlr_el1, x0

    ldr    x0, =HCR_VALUE
    msr    hcr_el2, x0

    ldr    x0, =SCR_VALUE
    msr    scr_el3, x0

    ldr    x0, =SPSR_VALUE
    msr    spsr_el3, x0

    adr    x0, el1_entry
    msr    elr_el3, x0

    eret
```

ご覧のように、このコードのほとんどはいくつかのシステムレジスタの設定から
なっています。これらのレジスタを一つずつ調べていきましょう。そのためには
まず、[AArch64レファレンスマニュアル](https://developer.arm.com/docs/ddi0487/ca/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile)を
ダウンロードする必要があります。このドキュメントには`ARM.v8`アーキテクチャの
詳細な仕様が記載されています。

#### SCTLR_EL1, システム制御レジスタ (EL1), AArch64レファレンスマニュアルの2654ページ

```
    ldr    x0, =SCTLR_VALUE_MMU_DISABLED
    msr    sctlr_el1, x0
```

ここでは、`sctlr_el1`システムレジスタの値を設定しています。 `sctlr_el1`は
EL1で動作する際のプロセッサのさまざまなパラメータを設定する役割を果たします。
たとえば、キャッシュを有効にするか否かや、私たちにとって最も重要なMMU(メモリ
管理ユニット）を作動させるか否かなどを制御します。`sctlr_el1`は、EL1以上の
すべての例外レベルからアクセスできます（`_el1`という後置詞から推測できるでしょう）。

`SCTLR_VALUE_MMU_DISABLED`定数は、[`sysregs.h#L16`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/include/arm/sysregs.h#L16)で
定義されています。この値の各ビットは次のように定義されています。

* `#define SCTLR_RESERVED                  (3 << 28) | (3 << 22) | (1 << 20) | (1 << 11)` `sctlr_el1`レジスタの説明の中でいくつかのビットは`RES1`とマークされています。これらのビットは将来の使用のために予約されており，`1`で初期化する必要があります。
* `#define SCTLR_EE_LITTLE_ENDIAN          (0 << 25)` 例外の[エンディアン](https://en.wikipedia.org/wiki/Endianness)。このフィールドは、EL1での明示的なデータアクセスのエンディアンを制御します。ここでは`リトルエンディアン`形式でのみ動作するようにプロセッサを設定します。
* `#define SCTLR_EOE_LITTLE_ENDIAN         (0 << 24)` 前のフィールドと似ていますが、このフィールドはEL1ではなくEL0での明示的なデータアクセスのエンディアンを制御します。
* `#define SCTLR_I_CACHE_DISABLED          (0 << 12)` 命令キャッシュを無効にします。ここでは簡単にするためにすべてのキャッシュを無効にします。データキャッシュと命令キャッシュについての詳細は[こちら](https://stackoverflow.com/questions/22394750/what-is-meant-by-data-cache-and-instruction-cache)をご覧ください。
* `#define SCTLR_D_CACHE_DISABLED          (0 << 2)` データキャッシュを無効にします。
* `#define SCTLR_MMU_DISABLED              (0 << 0)` MMUを無効にします。MMUはレッスン6までは無効にする必要があります。そこではページテーブルを用意して、仮想メモリで動作するようにします。

#### HCR_EL2, ハイパーバイザ制御レジスタ (EL2), AArch64レファレンスマニュアルの2487ページ

```
    ldr    x0, =HCR_VALUE
    msr    hcr_el2, x0
```

私たちは独自の [ハイパーバイザ](https://en.wikipedia.org/wiki/Hypervisor)を
実装する予定はありません。しかし、このレジスタを使用する必要があります。
中でも、このレジスタはEL1での実行状態を制御するからです。実行状態は
`AArch32`ではなく、`AArch64`でなければなりません。これは[`sysregs.h#L22`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/include/arm/sysregs.h#L22)で設定しています。

#### SCR_EL3, セキュア構成レジスタ (EL3), AArch64レファレンスマニュアルの2648ページ

```
    ldr    x0, =SCR_VALUE
    msr    scr_el3, x0
```

このレジスタは、セキュリティ設定を構成する役割を果たします。たとえば、
すべての下位レベルを「セキュア」または「ノンセキュア」のどちらの状態で
実行するかを制御します。また、EL2での実行状態も制御します。ここでは、
EL2では`AArch64`状態で実行し、下位の例外レベルはすべて「ノンセキュア」に
なるように[`sysregs.h#L26`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/include/arm/sysregs.h#L26)で設定しています。

> **訳注**: QEMUではEL2で実行されるため、このレジスタにはアクセスできない。そのため、QEMUで実行する場合は、この2行は削除する。

#### SPSR_EL3, プログラム状態保存レジスタ (EL3), AArch64レファレンスマニュアルの389ページ

```
    ldr    x0, =SPSR_VALUE
    msr    spsr_el3, x0
```

このレジスタは皆さんにはすでにおなじみでしょう。例外レベルを変更する
プロセスについて説明した際に触れているからです。`spsr_el3`には
`eret`命令を実行すると復元されるプロセッサの状態が格納されます。
プロセッサの状態とは何かについて、少し説明しておきましょう。
プロセッサの状態には以下の情報が含まれます。

* **条件フラグ** これらのフラグには直前に実行された操作に関する情報が
含まれています。すなわち、結果は負（Nフラグ）、ゼロ（Aフラグ）、符号
なしのオーバーフロー（Cフラグ）、符号付きのオーバーフロー（Vフラグ）の
いずれであったかという情報です。これらのフラグの値は条件付き分岐命令で
使用することができます。たとえば，`b.eq`命令は，直前の比較演算の結果が
0に等しい場合にのみ，指定されたラベルにジャンプします。プロセッサは
Zフラグが1にセットされているかをテストすることでこれをチェックします。

* **割り込み禁止ビット** これらのビットは、さまざまな種類の割り込みを
有効/無効にすることができます。

* その他の情報は、例外処理の後にプロセッサの実行状態を完全に復元する
ために必要です。

通常、`spsr_el3`はEL3で例外が発生したときに自動的に保存されます。しかし、
このレジスタは書き込み可能であるため、この事実を利用して手動でプロセッサの
状態を準備します。[ここ](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson02/include/arm/sysregs.h#L35)では`SPSR_VALUE`を用意し、
以下のフィールドを初期化しています。

* `#define SPSR_MASK_ALL        (7 << 6)` ELをEL1に変更した後、すべての種類の割り込みをマスクします（または無効にします。同じ意味です）。
* `#define SPSR_EL1h        (5 << 0)` EL1では、専用のスタックポインタを使用するか、EL0のスタックポインタのいずれかを使用することができます。`EL1h`モードは、EL1専用のスタックポインタを使用することを意味します。

> **訳注**: QEMUではEL2で実行されるため、同じ設定を`spsr_el2`に対して行います。

#### ELR_EL3, 例外リンクレジスタ (EL3), AArch64レファレンスマニュアルの351ページ

```
    adr    x0, el1_entry
    msr    elr_el3, x0

    eret
```

`elr_el3`には`eret`命令が実行された後に復帰するアドレスが格納されます。
ここでは、このアドレスに`el1_entry`ラベルの位置を設定しています。

> **訳注**: QEMUではEL2で実行されるため、同じ設定を`elr_el2`に対して行います。

### 結論

だいたいこんな感じです。`el1_entry`関数に入ると、すでにEL1モードで実行
されているはずです。さあ、試してみてください。


```bash
$ make run
aarch64-none-elf-gcc -Iinclude -MMD -c src/boot.S -o build/boot_s.o
aarch64-none-elf-ld -T src/linker.ld -o build/kernel8.elf  build/kernel_c.o build/mini_uart_c.o build/printf_c.o build/boot_s.o build/mm_s.o build/utils_s.o
aarch64-none-elf-objcopy build/kernel8.elf -O binary kernel8.img
qemu-system-aarch64 -m 1024 -M raspi3 -serial null -serial mon:stdio -nographic -kernel kernel8.img
Exception level: 1
```

##### 前ページ

1.5 [カーネルの初期化: 演習](../../ja/lesson01/exercises.md)

##### 次ページ

2.2 [プロセッサの初期化: Linux](../../ja/lesson02/linux.md)
