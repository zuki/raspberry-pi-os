## 3.1: 割り込み

レッスン1では、ハードウェアとの通信方法について説明しました。しかし、たいていの
場合、通信のパターンはそれほど単純ではありません。通常、このパターンは非同期的な
ものです。私たちはデバイスに何らかのコマンドを送りますが、デバイスはすぐには応答
しません。代わりに作業が完了した時に通知してくれます。このような非同期の通知は
「割り込み」と呼ばれます。通常の実行フローに割り込み、プロセッサに「割り込み
ハンドラ」を実行させるからです。

オペレーティングシステムの開発において、特に有用なデバイスがあります。システム
タイマです。これは事前に定義した頻度でプロセッサに定期的に割り込みをかけるように
設定できるデバイスです。タイマは特別な応用の一つとしてプロセスのスケジュー
リングに使われます。スケジューラは、各プロセスの実行時間を測定し、その情報を
もとに次に実行するプロセスを選択する必要があります。この計測にタイマによる
割り込みが使われます。

プロセスのスケジューリングについては、次のレッスンで詳しく説明しますが、
ここでは、システムタイマを初期化し、タイマ割り込みハンドラを実装することに
します。

### 割り込みと例外

ARM.v8アーキテクチャでは、割り込みはより一般的な用語である「例外」の一部です。
例外には次の4つのタイプがあります。

* **同期例外** このタイプの例外は、常に現在実行中の命令によって引き起こされます。
たとえば、`str`命令を使用して存在しないメモリ位置にデータを格納してしまうことが
あります。この場合、同期例外が発生します。同期例外は「ソフトウェア割り込み」を発生
させるためにも使用できます。ソフトウェア割り込みとは`svc`命令によって意図的に
発生させる同期例外です。レッスン5ではこのテクニックを使ってシステムコールを
実装します。
* **IRQ（Interrupt Request）** 通常の割り込みです。常に非同期であり、現在実行
中の命令とは何の関係もありません。同期例外とは対照的に、常にプロセッサ自身では
なく、外部のハードウェアによって生成されます。
* **FIQ (Fast Interrupt Request)** このタイプの例外は「高速割り込み」と呼ばれ、
例外の優先順位を決めるためだけに存在します。一部の割り込みを「通常」、その他を
「高速」として設定することができます。高速な割り込みは最初にシグナルが送られ、
別の例外ハンドラで処理されます。Linuxでは高速割り込みは使用しません。私たちも
使用するつもりはありません。
* **SError (System Error)** `IRQ`や`FIQ`と同様に、`SError`例外も非同期であり、
外部のハードウェアによって生成されます。`IRQ`や`FIQ`とは異なり、`SError`は常に
何らかのエラー状態を示します。どのような場合に`SError`が発生するのかを説明して
いる例を[ここ](https://community.arm.com/processors/f/discussions/3205/re-what-is-serror-detailed-explanation-is-required)で見ることができます。

### 例外ベクタ

例外の各タイプには独自のハンドラが必要です。また、例外が発生した実行状態ごとに
個別のハンドラを定義する必要があります。例外処理の観点から4つの興味深い実行
状態があります。EL1を対象とした場合、これらの状態は以下のように定義できます。

1. **EL1t** スタックポインタがEL0と共有されている時に、EL1で例外が発生した。
これは`SPSel`レジスタが値`0`を保持している場合に起こります。
2. **EL1h** EL1に専用のスタックポインタが割り当てられていた時に、EL1で例外が
発生した。これは`SPSel`が値`1`を保持していることを意味し、これが現在使用されて
いるモードです。
3. **EL0_64** 64ビットモードで実行中のEL0で例外が発生した。
4. **EL0_32** 32ビットモードで実行中のEL0で例外が発生した。

合計で16個の例外ハンドラ（4つの例外レベル×4つの実行状態）を定義する必要があります。
すべての例外ハンドラのアドレスを保持する特別な構造体は、*例外ベクタテーブル*
または単に*ベクタテーブル*と呼ばれています。ベクタテーブルの構造は[AArch64リファレンスマニュアル](https://developer.arm.com/docs/ddi0487/ca/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile)の
1876ページにある「表D1-7 ベクタテーブルベースアドレスからのベクタオフセット」で
定義されています。ベクタテーブルは例外ベクタの配列と考えることができます。各例外
ベクタ（またはハンドラ）は対象の例外を処理するための命令シーケンスです。「AArch64
リファレンスマニュアル」の「表D1-7」によると、各例外ベクタは最大で0x80バイトを
占めることができます。これは大した量ではありませんが、例外ベクタから他のメモリ
位置にジャンプすることを妨げるものはありません。

これらのすべては例を見ればもっと明らかだと思います。それでは、RPI-OSで例外ベクタが
どのように実装されているかを見てみましょう。例外処理に関連するものはすべては
[entry.S](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S)で定義されています。今からそれを調べていきましょう。

最初の便利なマクロは[ventry](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S#L12)であり、
ベクタテーブルのエントリの作成に使用されます。

```
    .macro    ventry    label
    .align    7
    b    \label
    .endm
```

この定義から推測されるように、例外の処理は例外ベクタの中では行わず、
マクロの`label`引数として与えられたラベルにジャンプします。ここでは
`.align 7`命令が必要です。すべての例外ベクタは互いに0x80(=2^7)バイトの
オフセットに配置される必要があるためです。

ベクタテーブルは[`entry.S#L64`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S#L64)で
定義されており、16個の`ventry`定義で構成されています。今のところ`EL1h`からの
`IRQ`を処理することにしか興味がありませんが、それでも16個のハンドラをすべて
定義する必要があります。これはハードウェアの要件ではなく、何か問題が発生した
際に意味のあるエラーメッセージを表示させたいためです。通常のフローでは絶対に
実行されないはずのハンドラにはすべて`invalid`の後置詞をつけ、[handle_invalid_entry](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S#L3)
マクロを使用しています。このマクロがどのように定義されているかを見てみましょう。

```
    .macro handle_invalid_entry type
    kernel_entry
    mov    x0, #\type
    mrs    x1, esr_el1
    mrs    x2, elr_el1
    bl    show_invalid_entry_message
    b    err_hang
    .endm
```

1行目では`kernel_entry`という別のマクロが使われているのがわかります。これに
ついてはすぐに説明します。次に、[show_invalid_entry_message](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.c#L34)を
呼び出すために3つの引数を用意します。最初の引数は例外タイプで[`entry.h#L6`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/include/entry.h#L6)のいずれかの
値を取ります。これはどの例外ハンドラが実行されるのかを正確に教えてくれます。
2番目の引数は最も重要なもので、`ESR`（Exception Syndrome Register）と
呼ばれています。この引数は「AArch64リファレンスマニュアル」の2431ページに記載
されている`esr_el1`レジスタから取得します。このレジスタには、例外の原因についての
詳しい情報が含まれています。3番目の引数は特に同期例外の場合に重要です。この値は
すでにおなじみの`elr_el1`レジスタから取得します。`elr_el1`レジスタには例外発生
時に実行されていた命令のアドレスが格納されています。同期例外の場合、これは例外を
発生させた命令でもあります。`show_invalid_entry_message`関数がこれらすべての
情報を画面に表示した後は、他にできることはあまりないので、プロセッサを無限
ループにします。

### レジスタ状態を保存する

例外ハンドラの実行終了後には、すべての汎用レジスタの値が例外発生前と同じになる
ようにします。このような機能を実装しないと、現在実行中のコードとは関係のない
割り込みが、そのコードの動作に予想外の影響を与えることになります。そのため、
例外の発生後に最初にしなければならないことは、プロセッサの状態を保存すること
です。これは[kernel_entry](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S)マクロで
行われています。このマクロは非常にシンプルです。レジスタ`x0 - x30`をスタックに
格納するだけです。また、対応する[kernel_exit](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S#L37)マクロがあり、
これは例外ハンドラの実行終了後に呼び出されます。`kernel_exit`は`x0 - x30`
レジスタの値を書き戻してプロセッサの状態を復元します。このマクロはまた、`eret`
命令を実行して通常の実行フローに戻します。ところで、例外ハンドラを実行する前に
保存する必要があるのは汎用レジスタだけではありません。しかし、今回のシンプルな
カーネルでは今のところこれで十分です。この後のレッスンで`kernel_entry`マクロと
`kernel_exit`マクロにさらに機能を追加していきます。

### ベクタテーブルを設定する

さて、これでベクタテーブルの準備はできましたが、プロセッサはそれがどこにあるのか
知らないので使うことができません。例外処理を機能させるためには、`vbar_el1`
（ベクタベースアドレスレジスタ）にベクタテーブルのアドレスを設定する必要が
あります。これは[`irq.S#L2`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.S#L2)で行っています。

```
.globl irq_vector_init
irq_vector_init:
    adr    x0, vectors        // load VBAR_EL1 with virtual
    msr    vbar_el1, x0        // vector table address
    ret
```

### 割り込みをマスク/アンマスクする

もうひとつ必要なことは、すべてのタイプの割り込みをアンマスクすることです。
割り込みの「アンマスク」とはどういうことか説明しましょう。特定のコードが
非同期割込みを受けないようにする必要がある場合があります。たとえば、
`kernel_entry`マクロの途中で割込みが発生した場合を想像してみてください。
この場合、プロセッサの状態は上書きされて失われてしまいます。そのため、
例外ハンドラが実行されると、プロセッサは自動的にすべてのタイプの割り込みを
無効にします。これを割り込みの「マスク」といいますが、これも必要に応じて手動で
行うことができます。

多くの人は、例外ハンドラの実行中はずっと割り込みをマスクしなければならないと
勘違いしています。これは真実ではありません。プロセッサの状態を保存した後に
割り込みをアンマスクすることは全く問題はありません。そのため、ネストした割り
込みもできるのです。今すぐにこれを行うわけではありませんが、これは覚えて
おくべき重要な情報です。

[次の2つの関数](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.S#L7-L15)が
割り込みのマスクとアンマスクを担当します。

```
.globl enable_irq
enable_irq:
    msr    daifclr, #2
    ret

.globl disable_irq
disable_irq:
    msr    daifset, #2
        ret
```

ARMプロセッサの状態にはさまざまな種類の割り込みのマスク状態を保持する
4つのビットがあります。これらのビットは以下のように定義されています。

* **D** デバッグ例外をマスクします。これは特別なタイプの同期例外です。
当然ですが、すべての同期例外をマスクすることはできませんが、デバッグ例外を
マスクできるフラグを個別に用意しておくと便利です。
* **A** `SErrors`をマスクします。`SErrors`は非同期アボートと呼ばれることが
あるため、`A`と呼ばれています。
* **I** `IRQ`をマスクします。
* **F** `FIQ`をマスクします。

さて、割り込みマスクの状態を変更する役割を持つレジスタがなぜ`daifclr`と
`daifset`と呼ばれるかはお分かりいただけたと思います。これらのレジスタは
プロセッサの状態の割り込みマスクの状態ビット(D, A, I, F)のセットとクリア
をするからです。

最後に気になるのはなぜ両関数で定数値2を使っているのかということでしょう。
それは、ここでは2番目のビット（`I`）の設定とクリアだけを行いたいからです。


### 割り込みコントローラを設定する

通常、デバイスはプロセッサに直接割り込みをかけることはありません。代わりに
割り込みコントローラに仕事を依頼します。割込みコントローラはハードウェアから
送られてくる割込みを有効にしたり、無効にしたりするために使用できます。
また、割り込みコントローラを使って、どのデバイスが割り込みを発生させた
のかを把握することもできます。
Raspberry PIは、[BCM2837 ARMペリフェラルマニュアル](https://github.com/raspberrypi/documentation/files/1888662/BCM2837-ARM-Peripherals.-.Revised.-.V2-1.pdf)
の109ページに記載されている独自の割り込みコントローラを持っています。

Raspberry Piの割り込みコントローラには3つのレジスタがあり、すべてのタイプの
割り込みの有効/無効の状態を保持しています。今のところ、関心のあるのはタイマ
割り込みだけです。これらの割り込みはマニュアルの116ページに記載されている[ENABLE_IRQS_1](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/include/peripherals/irq.h#L10)
レジスタを使って有効にすることができます。マニュアルによると、割り込みは2つの
バンクに分けられています。最初のバンクは割り込み`0 - 31`で構成されており、
`ENABLE_IRQS_1`レジスタの対象のビットを設定することでこれらの割り込みの有効/無効
を設定することができます。また、最後の32個の割り込みに対応するレジスタ
`ENABLE_IRQS_2`と、ARMローカル割り込みと共にいくつかの一般的な割り込みを制御
するレジスタ`ENABLE_BASIC_IRQS`があります（ARMローカル割り込みについては、
このレッスンの次の章で説明します）。しかし、このマニュアルには多くの間違いが
あり、そのうちの1つは今回の議論に直接関係しています。ペリフェラルの割り込み
テーブル（マニュアルの113ページに記載されています）には`0 - 3`行目にシステム
タイマからの4つの割り込みが入っているはずです。Linuxソースコードのリバース
エンジニアリと[その他のいくつかの情報源](http://embedded-xinu.readthedocs.io/en/latest/arm/rpi/BCM2835-System-Timer.html)から、タイマ割り込みの0と2はGPUが使用
するために予約されており、タイマ割り込みの1と3が他の目的に使用できることが
わかりました。システムタイマIRQ番号1を有効にする[関数](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.c#L29) を
以下に示します。

```
void enable_interrupt_controller()
{
    put32(ENABLE_IRQS_1, SYSTEM_TIMER_IRQ_1);
}
```

### 汎用IRQハンドラ

先の説明で、すべての`IRQ`の処理を担当する1つの例外ハンドラがあることを覚えて
いると思います。このハンドラは[`irq.c#L39`](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.c#L39)で定義されています。

```
void handle_irq(void)
{
    unsigned int irq = get32(IRQ_PENDING_1);
    switch (irq) {
        case (SYSTEM_TIMER_IRQ_1):
            handle_timer_irq();
            break;
        default:
            printf("Unknown pending irq: %x\r\n", irq);
    }
}
```

ハンドラでは、どのデバイスが割り込みを発生させたのかを把握する方法が必要です。
これには割り込みコントローラが助けてくれます。割り込みコントローラは割り込み
`0 - 31`の割り込み状態を保持する`IRQ_PENDING_1`レジスタを持っています。
このレジスタを使用して、現在の割り込みがタイマによって生成されたものか、他の
デバイスによって生成されたものかを確認し、デバイス固有の割り込みハンドラを
呼び出すことができます。なお、複数の割り込みが同時に発生する可能性があります。
このため、各デバイス固有の割り込みハンドラは、割り込みの処理が完了したことを
確認してから`IRQ_PENDING_1`の割り込み保留ビットをクリアしなければなりません。
同じ理由で、製品版のOSでは、割り込みハンドラのswitchコンストラクトをループで
包むことになるでしょう。そうすれば、1回のハンドラ実行で複数の割り込みを処理
することができるからです。

### タイマの初期化

Raspberry Piのシステムタイマは非常にシンプルなデバイスで、クロックが1 tick
刻むたびに値が1ずつ増加するカウンタを備えています。また、割り込みコントローラに
接続されている4本の割り込みライン（そのため4つの異なる割り込みを発生させる
ことができます）とそれに対応する4つのコンペアレジスタを備えています。カウンタの
値がいずれかのコンペアレジスタに格納されている値と等しくなると対応する
割り込みが発生します。このため、システムタイマ割り込みを使用する前に、いずれかの
コンペアレジスタをゼロ以外の値で初期化する必要があります。この値が大きいほど、
割り込みの発生が遅くなります。これは[timer_init](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/timer.c#L8) 関数で行っています。

```
const unsigned int interval = 200000;
unsigned int curVal = 0;

void timer_init ( void )
{
    curVal = get32(TIMER_CLO);
    curVal += interval;
    put32(TIMER_C1, curVal);
}
```

1行目で現在のカウンタ値を読み込み、2行目でカウンタ値を増加させ、3行目で
割り込み番号1のコンペアレジスタの値を設定しています。`interval`値を操作する
ことで、最初のタイマ割り込みがどのくらいで発生するかを調整できます。

### タイマ割り込みを処理する

ようやくタイマ割り込みハンドラにたどり着きました。実は非常にシンプルです。

```
void handle_timer_irq( void )
{
    curVal += interval;
    put32(TIMER_C1, curVal);
    put32(TIMER_CS, TIMER_CS_M1);
    printf("Timer interrupt received\n\r");
}
```

ここではまず、同じ時間間隔で次の割り込みが発生するようにコンペアレジスタを
更新します。次に、`TIMER_CS`レジスタに1を書き込むことで割り込みの発生を確認
します。マニュアルでは`TIMER_CS`は「タイマ制御/状態(Timer Control/Status)」
レジスタと呼ばれています。このレジスタのビット[0:3]は、4つの利用可能な割り込み
ラインの1つから来る割り込みを確認するために使用できます。

### 結論

最後に見るべきものは、これまでに説明したすべての機能をまとめている[kernel_main](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/kernel.c#L7)関数
です。このサンプルをコンパイルして実行すると、割り込みが入ると"Timer interrupt received"と
いうメッセージが表示されるはずです。是非、自分でやってみてください。そして、コードを
よく吟味して、実験することを忘れないでください。

##### 前ページ

2.3 [プロセッサの初期化: 演習](../../ja/lesson02/exercises.md)

##### 次ページ

3.2 [割り込み処理: Linuxにおける低レベル割り込み処理](../../ja/lesson03/linux/low_level-exception_handling.md)
